# Этап 4: Favorites (UC-07)

## Цель этапа
Реализовать систему избранного: менти может добавлять и удалять менторов из избранного, просматривать список избранного; ментор видит только общее количество добавлений в избранное (без списка пользователей).

## Use Case (из [progect.md](progect.md))
- **UC-07. Избранное**
  - Менти может добавить **любого** ментора в избранное (статус приёма заявок не влияет).
  - Статус ментора не влияет на добавление.
  - Ментор видит только **общее количество** добавлений в избранное (не кто добавил).

## Контекст проекта
- Стек: backend NestJS + Prisma + PostgreSQL; frontend React + TypeScript + Vite + Tailwind + React Query + React Router.
- В схеме уже есть: User, Profile, Mentor, Mentee, Tag, MentorTag. Модели **Favorite** нет.
- Роль «менти» определяется так: у пользователя есть Profile и связанная сущность Mentee ([backend/src/modules/mentees](backend/src/modules/mentees)). По `req.user.id` находится Profile, затем `profile.mentee`; если его нет — пользователь не менти.
- В каталоге менторов уже возвращается `favoritesCount: 0` ([backend/src/modules/mentors/mentors.service.ts](backend/src/modules/mentors/mentors.service.ts), строка 119); тип [MentorCatalogItem](frontend/src/shared/types/mentors.ts) уже содержит `favoritesCount`. На карточке есть заглушка кнопки «В избранное» ([MentorsCatalogPage.tsx](frontend/src/features/mentors/pages/MentorsCatalogPage.tsx)).
- Действия с избранным доступны **только пользователю с ролью менти**. Ментор не может добавлять кого-либо в избранное и не видит список «кто добавил меня».

---

## 1. Backend

### 1.1. Prisma: модель Favorite

**Файл:** [backend/prisma/schema.prisma](backend/prisma/schema.prisma)

- Добавить модель **Favorite**:
  - `id` String @id @default(uuid())
  - `menteeId` String
  - `mentorId` String
  - `createdAt` DateTime @default(now())
  - Связи: `mentee Mentee @relation(...)`, `mentor Mentor @relation(...)`
  - Уникальная пара: `@@unique([menteeId, mentorId])` (один менти не может добавить одного ментора дважды)
  - Внешние ключи с `onDelete: Cascade` для mentee и mentor (при удалении менти/ментора записи избранного удаляются).

- В моделях **Mentee** и **Mentor** добавить обратные связи:
  - Mentee: `favorites Favorite[]`
  - Mentor: `favorites Favorite[]`

- Выполнить миграцию: `npx prisma migrate dev --name add_favorites`.

### 1.2. Модуль Favorites

**Структура:** `backend/src/modules/favorites/`

- **favorites.service.ts**
  - Получение текущего менти по userId: через `Profile.findUnique({ where: { userId }, include: { mentee: true } })`. Если `!profile?.mentee` — выбросить `ForbiddenException` с сообщением на русском (например: «Доступно только для пользователей с ролью «Менти»»).
  - **add( userId: string, mentorId: string ):** проверить, что ментор с `mentorId` существует; получить menteeId текущего пользователя; создать запись Favorite (menteeId, mentorId). Если запись уже есть (уникальный ключ), вернуть успех без дублирования (идемпотентность) или выбросить 409 — на усмотрение, в постановке зафиксировать: **идемпотентно** — при повторном POST возвращать 200 и существующую запись.
  - **remove( userId: string, mentorId: string ):** по userId найти menteeId; удалить запись Favorite по (menteeId, mentorId). Если записи не было — 200 без ошибки (идемпотентно).
  - **findAllByMentee( userId: string ):** вернуть список избранного текущего менти — массив элементов с данными ментора (достаточно для отображения в списке: id ментора, имя/фамилия из Profile, специальность, теги, acceptsRequests, количество в избранном для каждого и т.п.). Формат согласовать с фронтом (см. п. 2.2).

- **favorites.controller.ts**
  - Все маршруты под **JwtAuthGuard**.
  - `POST /api/favorites` — body: `{ mentorId: string }`. Вызов сервиса add(req.user.id, mentorId). Ответ: 201 + созданная запись или 200 при идемпотентности.
  - `DELETE /api/favorites/:mentorId` — параметр mentorId из URL. Вызов remove(req.user.id, mentorId). Ответ: 204 No Content.
  - `GET /api/favorites` — список избранного текущего менти. Ответ: 200 + массив (формат из сервиса).

- **DTO**
  - `AddFavoriteDto`: поле `mentorId` (UUID), валидация через class-validator (`@IsUUID()`).

- **favorites.module.ts**
  - Импорт PrismaModule/PrismaService; контроллер и сервис; экспорт FavoritesService при необходимости.

- **Регистрация в AppModule:** добавить FavoritesModule.

### 1.3. Подсчёт количества добавлений в избранное (для ментора)

- В **MentorsService** (каталог и деталь ментора):
  - В методе, который формирует список каталога (`findCatalog`): вместо константы `favoritesCount: 0` считать реальное количество: по каждому ментору `Favorite.count({ where: { mentorId: m.id } })` или один запрос с группировкой по mentorId (например, через `groupBy` или подзапрос), чтобы не делать N+1 запросов. Рекомендация: один раз получить все mentorId из выборки, затем `Favorite.groupBy({ by: ['mentorId'], where: { mentorId: { in: ids } }, _count: { mentorId: true } })` и подставить значения в items.
  - В методе **findById** (деталь ментора): добавить в ответ поле `favoritesCount` — количество записей Favorite по данному mentorId.

- В типах на фронте: в [MentorDetail](frontend/src/shared/types/mentors.ts) при необходимости добавить `favoritesCount?: number` (если ещё не добавлено).

### 1.4. Ошибки и права

- Если пользователь не менти (нет profile.mentee) при вызове POST/DELETE/GET favorites — ответ **403 Forbidden**, сообщение на русском.
- Если mentorId не передан или не UUID — **400** (валидация DTO).
- Если ментор с указанным mentorId не найден при добавлении — **404** с сообщением «Ментор не найден».
- Формат ошибок — единый (code, message, statusCode, path), как в текущем проекте.

---

## 2. Frontend

### 2.1. API и типы

- **Типы** (в `frontend/src/shared/types/mentors.ts` или в `features/favorites/`):
  - Элемент списка избранного: например `FavoriteMentorItem` (id ментора, firstName, lastName, specialty, tags, acceptsRequests, favoritesCount, createdAt и т.д. — в соответствии с ответом GET /api/favorites).
  - При необходимости общий тип для «краткой карточки» ментора переиспользовать или расширить.

- **API-функции** (например в `frontend/src/features/favorites/api/favoritesApi.ts`):
  - `addFavorite(mentorId: string)` — POST /api/favorites с body `{ mentorId }`. Требуется авторизация (JWT).
  - `removeFavorite(mentorId: string)` — DELETE /api/favorites/:mentorId. Требуется авторизация.
  - `getFavorites()` — GET /api/favorites. Требуется авторизация. Возвращает массив элементов избранного.

- Все запросы через существующий [apiClient](frontend/src/shared/api/axios.ts) (токен подставляется автоматически).

### 2.2. Кнопка «В избранное» в каталоге и на странице ментора

- **Каталог** ([MentorsCatalogPage.tsx](frontend/src/features/mentors/pages/MentorsCatalogPage.tsx)):
  - Для авторизованного пользователя с ролью **менти**: кнопка «В избранное» активна. При клике — вызов addFavorite(item.id). После успеха — обновить список избранного (например, инвалидировать запрос getFavorites) и при необходимости отобразить состояние «В избранном» (см. ниже).
  - Для авторизованного **менти** уже добавившего этого ментора: показывать состояние «В избранном» и кнопку «Удалить из избранного» (или одну кнопку-переключатель). Для этого при загрузке каталога нужно знать множество id менторов, которые уже в избранном: либо в ответ каталога для авторизованного пользователя добавить поле `inFavorites?: boolean` (тогда бэкенд должен отдавать его на основе текущего пользователя), либо на фронте один раз запросить GET /api/favorites и построить Set(mentorId). Рекомендация: **на фронте** при открытии каталога (если пользователь залогинен) запрашивать GET /api/favorites и хранить Set(mentorId); по нему показывать «В избранном» и переключать кнопку на «Удалить из избранного».
  - Для пользователя **без роли менти** (или не авторизованного): кнопку «В избранное» показывать неактивной или скрыть, с подсказкой «Доступно для менти» / «Войдите как менти».

- **Страница детали ментора** ([MentorDetailPage.tsx](frontend/src/features/mentors/pages/MentorDetailPage.tsx)):
  - Аналогично: для менти — активная кнопка «В избранное» / «Удалить из избранного» в зависимости от того, есть ли этот ментор в избранном. Отображение `favoritesCount` для ментора (если бэкенд отдаёт в детали).

- Обработка ошибок: 403 — показать сообщение «Доступно только для менти»; 404 — «Ментор не найден»; остальные — общее сообщение из [errorHandler](frontend/src/shared/lib/errorHandler.ts).

### 2.3. Страница «Избранное» `/favorites`

- Маршрут: зарегистрировать в роутере путь `/favorites` (защищённый авторизацией; при отсутствии роли менти можно показывать заглушку или редирект с сообщением).
- Страница:
  - Заголовок, например «Мои избранные менторы».
  - Запрос GET /api/favorites (React Query). Показ загрузки и ошибки (в т.ч. 403).
  - Список карточек менторов (можно переиспользовать вид карточки из каталога или упрощённый вариант): имя, фамилия, специальность, теги, статус приёма заявок, кнопка «Удалить из избранного» и ссылка «Подробнее» на `/mentors/:id`.
  - Если список пуст — сообщение «В избранном пока никого нет» и ссылка на каталог.

### 2.4. Навигация

- В главном меню (layout) добавить пункт «Избранное» с ссылкой на `/favorites`. Показывать его только авторизованным пользователям (и при желании только менти).

### 2.5. Инвалидация кеша React Query

- После addFavorite / removeFavorite инвалидировать запрос списка избранного (queryKey для getFavorites), чтобы страница `/favorites` и индикация «В избранном» в каталоге обновлялись без перезагрузки.

---

## 3. API-контракты (итого)

| Метод | URL | Доступ | Описание |
|-------|-----|--------|----------|
| POST | /api/favorites | JWT, только менти | Body: `{ "mentorId": "uuid" }`. Добавить ментора в избранное. 201 Created (или 200 при идемпотентности). 403 если не менти, 404 если ментор не найден. |
| DELETE | /api/favorites/:mentorId | JWT, только менти | Удалить ментора из избранного. 204 No Content. 403 если не менти. |
| GET | /api/favorites | JWT, только менти | Список избранного текущего менти. 200 + массив элементов с данными менторов. 403 если не менти. |

- Ответ GET /api/mentors (каталог) и GET /api/mentors/:id (деталь): поле **favoritesCount** заполняется реальным количеством записей Favorite по данному ментору.
- Все сообщения об ошибках на русском, формат ошибок — единый (code, message, statusCode, path).

---

## 4. Критерии приёмки

- В БД есть модель Favorite с полями menteeId, mentorId, уникальной парой (menteeId, mentorId); миграция применена.
- Только пользователь с ролью менти может вызывать POST/DELETE/GET favorites; иначе 403.
- POST /api/favorites добавляет запись; повторный POST с той же парой не создаёт дубликат (идемпотентно).
- DELETE /api/favorites/:mentorId удаляет запись; повторный DELETE — 204 без ошибки.
- GET /api/favorites возвращает список избранного с данными менторов.
- В каталоге и в детали ментора отображается актуальное favoritesCount.
- На фронте в каталоге и на странице ментора кнопка «В избранное» / «Удалить из избранного» работает для менти и отражает текущее состояние (в избранном или нет).
- Страница `/favorites` отображает список избранных менторов и кнопку удаления из избранного; при пустом списке показывается соответствующее сообщение.
- Не менти (или неавторизованный) не может добавить в избранное; отображается понятная подсказка или скрытая кнопка.

---

## 5. Зависимости

- Этап 2 (профиль и роли) должен быть выполнен: у пользователя есть возможность быть менти, есть сущность Mentee.
- Этап 3 (каталог менторов) выполнен: есть список и деталь ментора, куда встраиваются кнопка и favoritesCount.
- Этап 5 (заявки) не блокируется: кнопка «Оставить заявку» остаётся в зоне ответственности этапа 5.

После выполнения этапа 4 разработчик передаёт задачу на проверку по перечисленным критериям; у исполнителя не должно оставаться неоднозначностей по объёму и правилам доступа.