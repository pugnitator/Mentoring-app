# Этап 5: Requests System (UC-08, UC-09, UC-10)

## Цель этапа

Реализовать систему заявок на менторство: отправка заявки менти с сопроводительным письмом, просмотр входящих (ментор) и исходящих (менти) заявок, принятие или отклонение заявки ментором. При принятии — создание активной связи «ментор–менти» и открытие контактов. Email-уведомление ментору о новой заявке (базовый шаблон).

## Use Cases (из [progect.md](progect.md))

- **UC-08. Отправка заявки:** доступно только если ментор принимает заявки; обязательное сопроводительное письмо; статусы заявки: отправлена / принята / отклонена; email-уведомление ментору.
- **UC-09. Обработка заявки:** ментор может принять или отклонить заявку; при принятии — открываются контакты, создаётся активная связь «ментор–менти».
- **UC-10. Просмотр заявок:** ментор видит входящие заявки; менти видит отправленные заявки.

## Контекст проекта

- В схеме есть User, Profile, Mentor, Mentee, Tag, MentorTag, Favorite. Моделей **Request** и **Connection** нет.
- У ментора: `acceptsRequests`, `maxMentees`. Кнопки «Оставить заявку» на каталоге и странице ментора — заглушки (этап 5).
- Нефункциональные требования проекта ([progect.md](progect.md), разд. 7–8): REST API, JSON, JWT для защищённых запросов, время ответа API ≤ 500 мс, защита от XSS, CSRF, SQL-инъекций, единый формат ошибок (code, message), язык системы — русский.

---

# Часть 1. Функциональные требования

## 1.1. Backend: схема данных

**Файл:** [backend/prisma/schema.prisma](backend/prisma/schema.prisma)

**Модель Request**

- `id` String @id @default(uuid())
- `menteeId` String
- `mentorId` String
- `message` String (сопроводительное письмо)
- `status` Enum RequestStatus (см. ниже)
- `createdAt` DateTime @default(now())
- `updatedAt` DateTime @updatedAt
- Связи: `mentee Mentee`, `mentor Mentor`; при удалении mentee/mentor — Cascade.
- Ограничение: одна активная заявка на пару (menteeId, mentorId) в статусе SENT. Допускается повторная заявка после REJECTED (новая запись).

**Enum RequestStatus**

- SENT (отправлена)
- ACCEPTED (принята)
- REJECTED (отклонена)

**Модель Connection** (для этапа 6 — отвязка; в этапе 5 создаётся при принятии заявки)

- `id` String @id @default(uuid())
- `mentorId` String
- `menteeId` String
- `requestId` String @unique (заявка, по которой создана связь)
- `status` Enum ConnectionStatus (ACTIVE; позже в этапе 6 — DETACHED)
- `createdAt` DateTime @default(now())
- Поля для этапа 6: `detachedAt` DateTime?, `reason` String? — можно добавить сейчас или в этапе 6.
- Связи: mentor, mentee, request; уникальность пары (mentorId, menteeId) при status ACTIVE — одна активная связь на пару. При необходимости @@unique([mentorId, menteeId]) с учётом того, что после отвязки может быть новая связь — уточнить: либо одна запись на пару с полем status, либо несколько записей (история). Рекомендация: одна запись на пару, status ACTIVE | DETACHED; при DETACHED хранить detachedAt и reason.

**Enum ConnectionStatus**

- ACTIVE
- DETACHED

В модели Mentor: связь `requests Request[]`, `connections Connection[]`. В Mentee: `requests Request[]`, `connections Connection[]`. В Request: опционально `connection Connection?` (одна заявка — не более одной связи).

Миграция: `npx prisma migrate dev --name add_requests_and_connections`.

---

## 1.2. Backend: модуль Requests

**Структура:** `backend/src/modules/requests/`

**Сервис (requests.service.ts)**

- **create(userId, createRequestDto):** отправить заявку.
  - Определить menteeId по userId (Profile -> mentee). Если нет роли менти — 403.
  - Проверить существование ментора по mentorId; проверить mentor.acceptsRequests === true — иначе 400 «Ментор сейчас не принимает заявки».
  - Проверить лимит: количество активных Connection по этому ментору (status ACTIVE) < mentor.maxMentees — иначе 400 «У ментора достигнут лимит активных менти».
  - Не создавать дубликат: если есть Request с (menteeId, mentorId) в статусе SENT — 409 «Заявка уже отправлена».
  - Создать Request (menteeId, mentorId, message, status: SENT). Отправить email ментору о новой заявке (см. п. 1.5). Вернуть созданную заявку.
- **findIncoming(userId):** входящие заявки для ментора.
  - По userId найти mentor (Profile -> mentor). Если нет роли ментор — 403.
  - Вернуть список Request где mentorId = mentor.id, статус SENT (и при желании ACCEPTED/REJECTED для истории), с include mentee.profile (имя, фамилия, цель и т.д. для отображения). Сортировка по createdAt desc.
- **findOutgoing(userId):** исходящие заявки для менти.
  - По userId найти mentee. Если нет роли менти — 403.
  - Вернуть список Request где menteeId = mentee.id, с include mentor.profile и т.д., сортировка по createdAt desc.
- **accept(userId, requestId):** принять заявку.
  - По userId найти ментора. Проверить, что заявка с requestId принадлежит этому ментору и статус SENT. Иначе 404/400.
  - Проверить лимит maxMentees (текущее количество активных Connection по ментору). Если уже достигнут — 400.
  - Транзакция: обновить Request (status ACCEPTED, updatedAt); создать Connection (mentorId, menteeId, requestId, status ACTIVE).
  - Вернуть обновлённую заявку и при необходимости данные связи (контакты менти для отображения ментору — email/имя из Profile).
- **reject(userId, requestId):** отклонить заявку.
  - По userId найти ментора. Проверить, что заявка принадлежит ментору и статус SENT.
  - Обновить Request (status REJECTED). Вернуть обновлённую заявку.

**Контроллер (requests.controller.ts)**

- Все маршруты под JwtAuthGuard.
- `POST /api/requests` — body: CreateRequestDto (mentorId, message). 201 + заявка.
- `GET /api/requests/incoming` — входящие для ментора. 200 + массив.
- `GET /api/requests/outgoing` — исходящие для менти. 200 + массив.
- `PATCH /api/requests/:id/accept` — принять. 200 + заявка (и при необходимости контактные данные менти).
- `PATCH /api/requests/:id/reject` — отклонить. 200 + заявка.

**DTO**

- CreateRequestDto: mentorId (UUID), message (string, min length по соглашению, например 10–2000 символов). Валидация class-validator; сообщения на русском.

**Регистрация:** RequestsModule в AppModule.

---

## 1.3. Backend: создание Connection при принятии

- В методе accept после обновления заявки создавать запись Connection (mentorId, menteeId, requestId, status: ACTIVE). Это обеспечивает UC-09 («создаётся активная связь»). Отображение контактов: в ответ accept можно вернуть данные профиля менти (email пользователя, имя, фамилия) для показа ментору «контакт открыт». Детальная страница «Мои связи» и отвязка — этап 6.

---

## 1.4. Backend: email-уведомление при новой заявке

- Модуль уведомлений: создать минимальный сервис (например `backend/src/modules/notifications/` или общий `mail.service.ts`), использующий nodemailer. Конфигурация SMTP из переменных окружения (как в [backend/.env.example](backend/.env.example)).
- При создании заявки (после сохранения Request): асинхронно отправить письмо на email ментора (User.email через mentor.profile.user). Тема и текст — на русском, например: «Новая заявка на менторство», «Вам отправлена заявка от [имя менти]. Сопроводительное письмо: [первые N символов message]… Войдите в платформу, чтобы принять или отклонить заявку.» Отправка в фоне (не блокировать ответ API). Ошибки отправки логировать; при падении SMTP не отменять создание заявки.
- Учёт «полное отключение уведомлений» (UC-12) — в этапе 8; на этапе 5 можно не проверять настройки и всегда отправлять.

---

## 1.5. Frontend: функциональные требования

**Маршруты**

- `/mentors/:id/request` — страница отправки заявки (форма с полем «Сопроводительное письмо» и кнопка «Отправить»).
- `/requests/incoming` — входящие заявки (для ментора): список заявок с данными менти, кнопки «Принять» / «Отклонить» для заявок в статусе SENT; для принятых — показать контакт (email/имя менти).
- `/requests/outgoing` — исходящие заявки (для менти): список заявок с данными ментора и статусом (отправлена / принята / отклонена).

**Каталог и карточка ментора**

- Заменить заглушку «Оставить заявку — этап 5» на ссылку/кнопку перехода на `/mentors/:id/request`. Кнопка отображается только если mentor.acceptsRequests === true.
- На странице детали ментора (`/mentors/:id`) — то же: кнопка «Оставить заявку» ведёт на `/mentors/:id/request` при acceptsRequests.

**Форма заявки**

- Поле «Сопроводительное письмо» (textarea), обязательное, ограничение длины как на бэкенде. Отправка POST /api/requests с mentorId (из роута) и message. При успехе — редирект на `/requests/outgoing` или сообщение об успехе. Ошибки (ментор не принимает заявки, лимит, дубликат) отображать пользователю на русском.

**Списки заявок**

- Входящие: запрос GET /api/requests/incoming; для каждой заявки — имя/фамилия менти, цель (из профиля менти), дата, сокращённый текст письма, статус; для SENT — кнопки «Принять» / «Отклонить». При принятии — PATCH accept, обновить список и показать контакт (email/имя менти) в этой карточке.
- Исходящие: GET /api/requests/outgoing; карточки с данными ментора, датой, текстом письма, статусом (отправлена / принята / отклонена).

**Навигация**

- Пункты меню «Входящие заявки» (для ментора) и «Мои заявки» (для менти) со ссылками на `/requests/incoming` и `/requests/outgoing`. Отображать пункты в зависимости от роли (если роль известна на фронте).

**Права доступа**

- Страница отправки заявки: только авторизованный менти; иначе редирект или 403.
- Входящие заявки: только ментор; иначе 403.
- Исходящие заявки: только менти; иначе 403.

---

# Часть 2. Нефункциональные требования

## 2.1. Производительность

- **Время ответа API:** все эндпоинты модуля requests (POST/GET/PATCH) должны укладываться в **500 мс** (p95 или среднее — по принятой в проекте метрике). При необходимости: индексы Prisma по полям (menteeId, mentorId, status для Request; mentorId, menteeId для Connection); избегать N+1 (include только нужных связей).
- **Email:** отправка письма не должна блокировать ответ клиенту. Выполнять отправку после возврата ответа (например, fire-and-forget или очередь в памяти с минимальной задержкой). При недоступности SMTP не возвращать пользователю ошибку создания заявки.

## 2.2. Безопасность

- **Авторизация:** все эндпоинты `/api/requests/*` доступны только с валидным JWT (JwtAuthGuard). Проверка роли: только менти может создавать заявку и смотреть исходящие; только ментор — входящие и accept/reject.
- **Валидация входных данных:** DTO с class-validator; запрет на внедрение HTML/скриптов в поле message (санитизация или ограничение символов). Защита от SQL-инъекций — через Prisma (параметризованные запросы).
- **Идентификация ресурса:** при accept/reject проверять, что requestId принадлежит текущему ментору; при создании заявки — что mentorId существует и доступен. Не раскрывать чужие заявки.

## 2.3. Надёжность и целостность данных

- **Транзакция при принятии заявки:** обновление Request и создание Connection выполнять в одной транзакции Prisma, чтобы при сбое не оставалось заявки в статусе ACCEPTED без связи или связи без обновления заявки.
- **Идемпотентность:** повторный PATCH accept для уже принятой заявки возвращать 200 с текущим состоянием или 400 «Заявка уже обработана». Повторный PATCH reject для отклонённой — аналогично.

## 2.4. Контракты и совместимость

- **Формат:** REST, JSON для тела запросов и ответов ([progect.md](progect.md), разд. 8).
- **Формат ошибок:** единый объект (statusCode, code, message, timestamp, path); для ошибок валидации — code VALIDATION_ERROR; для бизнес-ошибок — осмысленные code (например MENTOR_NOT_ACCEPTING, LIMIT_REACHED, REQUEST_ALREADY_SENT).
- **Язык:** все сообщения пользователю (ошибки, подписи кнопок, уведомления, текст письма) — **на русском** (Language Policy, разд. 9).

## 2.5. Масштабируемость и эксплуатация

- **Запросы к БД:** не допускать N+1 при выдаче списков заявок (использовать include/select для mentee.profile, mentor.profile одним запросом).
- **Логирование:** логировать ошибки при отправке email и критические сценарии (например, отказ из-за лимита). Не логировать тело заявки (message) в открытом виде в production без необходимости.

## 2.6. Frontend: нефункциональные

- **Адаптивность:** страницы заявок и форма отправки должны корректно отображаться на мобильных и планшетах (responsive, по [progect.md](progect.md)).
- **Обработка ошибок:** отображение ошибок API через единый механизм (например, [getErrorMessage](frontend/src/shared/lib/errorHandler.ts)); не показывать сырые коды ответов пользователю.
- **Доступность:** кнопки и поля формы должны быть доступны с клавиатуры; сообщения об ошибках связаны с полями (aria, label).

---

# Часть 3. API-контракты (сводка)


| Метод | URL                      | Кто          | Описание                                                                                                         |
| ----- | ------------------------ | ------------ | ---------------------------------------------------------------------------------------------------------------- |
| POST  | /api/requests            | Менти (JWT)  | Body: { mentorId, message }. 201 + заявка. 400 если ментор не принимает / лимит; 409 если заявка уже отправлена. |
| GET   | /api/requests/incoming   | Ментор (JWT) | 200 + массив входящих заявок.                                                                                    |
| GET   | /api/requests/outgoing   | Менти (JWT)  | 200 + массив исходящих заявок.                                                                                   |
| PATCH | /api/requests/:id/accept | Ментор (JWT) | 200 + заявка (и контакт менти при необходимости). 400 если лимит или заявка уже обработана.                      |
| PATCH | /api/requests/:id/reject | Ментор (JWT) | 200 + заявка.                                                                                                    |


Ответы списков: массив объектов с полями id, menteeId, mentorId, message, status, createdAt, updatedAt и вложенными данными профиля (mentee/profile или mentor/profile) для отображения имён и целей.

---

# Часть 4. Критерии приёмки

**Функциональные**

- Менти может отправить заявку только на ментора с acceptsRequests === true; при отправке обязательно поле message; создаётся запись Request в статусе SENT.
- Ментор видит входящие заявки; менти видит исходящие; отображаются корректные данные второй стороны и статусы.
- Ментор может принять или отклонить заявку в статусе SENT; при принятии создаётся Connection (ACTIVE), заявка переходит в ACCEPTED; ментору показываются контактные данные менти.
- При принятии проверяется лимит maxMentees; при его достижении возвращается ошибка.
- Ментору приходит email о новой заявке (при настроенном SMTP).
- Кнопки «Оставить заявку» в каталоге и на странице ментора ведут на форму отправки; форма и списки заявок работают по сценариям выше.

**Нефункциональные**

- Ответы API укладываются в 500 мс при типичной нагрузке; списки заявок без N+1.
- Все эндпоинты защищены JWT; проверка ролей (менти/ментор) и принадлежности заявки.
- Единый формат ошибок и сообщения на русском; валидация DTO.
- Транзакция при accept; email не блокирует ответ.
- Адаптивный UI; корректная обработка ошибок на клиенте.

---

# Часть 5. Зависимости и границы этапа

- **Этап 4 (Favorites):** выполнен; каталог и карточка ментора доступны.
- **Этап 6 (Connections):** в рамках этапа 5 создаётся модель Connection и запись при accept; страница «Мои связи», отвязка и скрытие контактов после отвязки — этап 6.
- **Этап 8 (Уведомления):** полная настройка отключения email и шаблоны писем «решение по заявке» — этап 8; на этапе 5 достаточно одного типа письма «новая заявка».