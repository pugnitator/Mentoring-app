# Этап 8: Notifications & Email (UC-12) — Постановка задачи для разработчика

## Цель этапа

Привести систему email-уведомлений к полному виду по UC-12: три типа писем (новая заявка, решение по заявке, отвязка) в виде HTML и текста, проверка настроек пользователя перед отправкой, возможность полного отключения уведомлений через настройки в профиле.

## Use Case (из [progect.md](progect.md))

- **UC-12. Уведомления**
  - Email-уведомления: новая заявка; решение по заявке (принята/отклонена); открепление.
  - Возможность **полного отключения** уведомлений.

## Контекст проекта

- В [backend/src/modules/notifications/mail.service.ts](backend/src/modules/notifications/mail.service.ts) уже реализованы: отправка письма о **новой заявке** ментору (`sendNewRequestNotification`) и письма **об отвязке** (`sendDetachNotification`). Письма только в текстовом формате (text); проверки настроек пользователя нет.
- В [requests.service](backend/src/modules/requests/requests.service.ts) при создании заявки вызывается `mail.sendNewRequestNotification`; при accept/reject письмо менти **не отправляется**. В [connections.service](backend/src/modules/connections/connections.service.ts) при detach вызывается `mail.sendDetachNotification`.
- Модели **NotificationSettings** в Prisma нет; переменные SMTP задаются через MAIL_HOST, MAIL_PORT, MAIL_USER, MAIL_PASSWORD, MAIL_FROM ([mail.service](backend/src/modules/notifications/mail.service.ts)).
- Стек: NestJS, nodemailer; без платных сервисов ([progect.md](progect.md)); в плане указана «очередь отправки» — в MVP достаточно асинхронной отправки без блокировки ответа API (текущий подход).

---

# Часть 1. Функциональные требования

## 1.1. Backend: настройки уведомлений

**Схема Prisma**

- Добавить модель **NotificationSettings**:
  - `id` String @id @default(uuid())
  - `userId` String @unique
  - `emailEnabled` Boolean @default(true)
  - `createdAt` DateTime @default(now())
  - `updatedAt` DateTime @updatedAt
  - Связь: `user User @relation(fields: [userId], references: [id], onDelete: Cascade)`
- В модели **User** добавить поле `notificationSettings NotificationSettings?`.
- Миграция: `npx prisma migrate dev --name add_notification_settings`.
- При первом обращении к настройкам пользователя: если записи нет — считать, что уведомления **включены** (emailEnabled = true). Создавать запись при первом GET или PATCH (ленивое создание) или при регистрации — на усмотрение; в постановке зафиксировать: **при GET/PATCH настроек** если записи нет — создавать с emailEnabled: true.

**API настроек**

- **GET /api/profile/me/notification-settings** (или /api/users/me/notification-settings). JWT. Ответ: `{ emailEnabled: boolean }`. Если записи нет — вернуть `{ emailEnabled: true }` и при желании создать запись.
- **PATCH /api/profile/me/notification-settings**. JWT. Body: `{ emailEnabled: boolean }`. Создать или обновить запись. Ответ: `{ emailEnabled: boolean }`.
- Реализация в существующем модуле profiles (или users): новый метод в сервисе, эндпоинты в контроллере. Валидация DTO (emailEnabled — boolean).

**Проверка перед отправкой писем**

- Перед вызовом любой отправки письма получателю определять userId по email (User.findUnique({ where: { email: toEmail } })) и проверять NotificationSettings: если запись есть и emailEnabled === false — **не отправлять** письмо. Если записи нет — отправлять (поведение по умолчанию «включено»).
- Место проверки: либо в MailService (метод-обёртка, который проверяет настройки и вызывает sendMail), либо в вызывающих сервисах (requests.service, connections.service). Рекомендация: **в вызывающих сервисах** — перед вызовом mail.sendXxx загружать настройки получателя по userId/email и не вызывать send, если emailEnabled === false. Тогда MailService остаётся без доступа к Prisma.

## 1.2. Backend: шаблоны писем (HTML + текст)

**Типы писем**

1. **Новая заявка** (уже есть текст; добавить HTML). Получатель: ментор. Содержание: от кого (имя, фамилия менти), превью сопроводительного письма, призыв зайти в платформу.
2. **Решение по заявке** (принята или отклонена). Получатель: менти. Содержание: кто принял/отклонил (имя, фамилия ментора), результат (заявка принята / заявка отклонена), при принятии — призыв зайти и посмотреть контакты. Сейчас это письмо **не отправляется** — добавить вызов в requests.service после accept и после reject.
3. **Отвязка** (уже есть текст; добавить HTML). Получатель: вторая сторона связи. Содержание: связь прекращена, имя инициатора (опционально), причина при наличии.

**Реализация**

- В MailService для каждого типа письма формировать **два варианта**: `text` (как сейчас) и `html` (простой HTML: заголовок, параграфы, без сложной вёрстки). В вызове `transporter.sendMail` передавать оба поля (text и html); почтовые клиенты покажут HTML при поддержке.
- Тексты и темы — **на русском** (Language Policy). Без подстановки недоверенного контента в HTML без экранирования (защита от XSS в письмах): имя/фамилия, превью сообщения, причина — экранировать при вставке в HTML (или использовать шаблоны с подстановкой только в текстовые узлы).
- Добавить метод **sendRequestDecisionNotification(params: { toEmail, accepted: boolean, mentorFirstName, mentorLastName })** и вызывать его в requests.service после успешного accept (accepted: true) и после reject (accepted: false). Перед вызовом проверять настройки получателя (менти).

## 1.3. Backend: интеграция проверки настроек

- **requests.service:** перед вызовом `mail.sendNewRequestNotification` загрузить настройки ментора (по mentorId -> User -> NotificationSettings); если emailEnabled === false — не вызывать send. Перед вызовом `sendRequestDecisionNotification` загрузить настройки менти; если выключено — не отправлять.
- **connections.service:** перед вызовом `mail.sendDetachNotification` загрузить настройки получателя (вторая сторона связи); если emailEnabled === false — не вызывать send.
- Не блокировать ответ API ожиданием отправки: вызовы отправки по-прежнему асинхронные (fire-and-forget после основного ответа).

## 1.4. Очередь отправки (MVP)

- В плане указано «async queue». В MVP достаточно **не блокировать** ответ клиенту: отправка выполняется после формирования ответа (например, через setImmediate, queueMicrotask или then после сохранения в БД). Отдельную очередь с персистентным хранилищем (Redis/Bull) не вводить, если иное не требуется. При падении SMTP — только логирование; повторная отправка не обязательна в рамках этапа.

## 1.5. Frontend: настройки уведомлений

- **Размещение:** в разделе профиля/настроек (например, отдельная вкладка «Уведомления» или блок на странице профиля). Текст на русском: «Email-уведомления», «Включить уведомления по email» / «Отключить уведомления по email».
- **Переключатель (toggle):** включено / выключено. Состояние загружать при открытии страницы (GET /api/profile/me/notification-settings). При переключении отправлять PATCH с новым значением emailEnabled; при успехе обновить локальное состояние, при ошибке — показать сообщение.
- Доступ: только авторизованному пользователю (JWT). Адаптивное отображение (responsive).

---

# Часть 2. Нефункциональные требования

## 2.1. Производительность

- **Время ответа API:** эндпоинты, которые инициируют отправку писем (создание заявки, accept, reject, detach), не должны ждать завершения отправки. Ответ клиенту отдаётся сразу после сохранения данных в БД; отправка письма выполняется асинхронно. Соблюдение общего NFR «время ответа API ≤ 500 мс» ([progect.md](progect.md)).
- GET/PATCH настроек уведомлений — быстрые запросы к БД без тяжёлой логики.

## 2.2. Безопасность и целостность

- **Проверка получателя:** отправка только на email, принадлежащий пользователю системы (не произвольный адрес). Тема и тело писем не должны содержать неэкранированный пользовательский ввод в HTML (имя, превью сообщения, причина — экранировать при подстановке в HTML).
- **Доступ к настройкам:** GET/PATCH notification-settings только для текущего пользователя (userId из JWT); нельзя изменить настройки другого пользователя.

## 2.3. Надёжность

- При недоступности SMTP или ошибке отправки — логировать ошибку; не возвращать ошибку пользователю в ответе на действие (создание заявки, accept, reject, detach). Письмо считается «best effort».
- Если настройки получателя не удалось загрузить — допускается отправить письмо (поведение по умолчанию «включено»), либо не отправлять при ошибке — зафиксировать в постановке: **при ошибке загрузки настроек не отправлять** письмо (безопаснее).

## 2.4. Контракты и язык

- Все тексты писем (темы, тела) и подписи в UI настроек — **на русском** ([progect.md](progect.md), разд. 9).
- REST, JSON для API настроек. Единый формат ошибок (statusCode, code, message).

## 2.5. Frontend

- Обработка ошибок при сохранении настроек (сеть, 4xx/5xx) — через общий механизм; сообщения на русском. Переключатель доступен с клавиатуры.

---

# Часть 3. API-контракты (дополнение)


| Метод | URL                                   | Доступ | Описание                                                                       |
| ----- | ------------------------------------- | ------ | ------------------------------------------------------------------------------ |
| GET   | /api/profile/me/notification-settings | JWT    | Текущие настройки. Ответ: { emailEnabled: boolean }.                           |
| PATCH | /api/profile/me/notification-settings | JWT    | Обновление. Body: { emailEnabled: boolean }. Ответ: { emailEnabled: boolean }. |


(Эндпоинты отправки писем не экспонируются; они вызываются внутренне при создании заявки, accept, reject, detach.)

---

# Часть 4. Критерии приёмки

**Функциональные**

- В БД есть модель NotificationSettings (userId, emailEnabled); миграция применена; при отсутствии записи считается emailEnabled = true.
- Письмо о новой заявке отправляется ментору только если у него emailEnabled !== false; письмо о решении по заявке (принята/отклонена) отправляется менти только если у него emailEnabled !== false; письмо об отвязке — только если у получателя emailEnabled !== false.
- Реализована отправка письма «Решение по заявке» (принята и отклонена) менти после accept и reject.
- Все три типа писем имеют текстовую и HTML-версии; темы и тела на русском; в HTML подстановки экранированы.
- Пользователь может включить/выключить email-уведомления в профиле; состояние сохраняется и учитывается при отправке.

**Нефункциональные**

- Ответы API действий (создание заявки, accept, reject, detach) не блокируются отправкой писем; время ответа укладывается в 500 мс.
- Ошибки отправки только логируются; настройки доступны только владельцу (JWT).
- UI настроек на русском, адаптивен, с обработкой ошибок.

---

# Часть 5. Зависимости и границы этапа

- Этапы 5 (заявки) и 6 (отвязка) выполнены; вызовы MailService уже есть. В этапе 8 добавляются: проверка NotificationSettings перед каждым отправлением, шаблон «решение по заявке», HTML-варианты писем, API и UI настроек.
- Восстановление пароля, верификация email и т.п. в объём этапа 8 не входят.

